:wink: :cry: :laughing: :yum:

# 更新 addDate、addTime等函数



## 需求说明

根据需求，4个函数公式均放在常用公式中，涉及需要调整的公式编辑器位置分别为：

- - 考勤统计设置-字段设置（/api/absence-statistics/v1/month/report/formula/functionList）
  - 假期规则设置-休假规则-编辑-发假规则的自定义公式（/api/abs/account/v1/formula/functionList）
  - 加班规则设置-加班类型编辑-调休假补偿时长的自定义公式 （/api/abs/account/v1/overtime/formula/functionList）



![image-20231107154947818](https://cdn.jsdelivr.net/gh/amonstercat/PicGo/202312211703427.png)



以**考勤统计设置-字段设置**为例，用户在进行考勤统计之前进行字段设置时，如果想要添加自定义字段(通过自定义函数计算)



需要将所有自定义函数展示出来，涉及到的接口为： **/api/absence-statistics/v1/month/report/formula/functionList**，因此需要在对应的 **hcm_abs_report_formula_function** 表中修改数据。



首先需要在该表中**新增addTime和minusTime函数**：



```sql
  /* 新增 addTime 、minusTime 函数 */ 
  
  -- 加班 overtime_formula_function --  
  INSERT INTO hcm_abs_overtime_formula_function ( value, field_label, meaning, param_explanation, example, example_text, result, group_name, group_biz, sort, group_sort, version) VALUES ( 'addTime()', 'addTime()', '获取指定时间增加指定时长后的时间', 'addTime（指定时间, 数字 , "单位"） 指定时间：必填，填入指定时间，指定时间参数支持到秒 数字：需为整数 单位：支持年、月、日、小时、分钟', '[{"type":"paragraph","children":[{"text":"addTime("},{"type":"tag","tagType":"fields","character":"日报记录.班次下班时间","id":"dailyReport#shiftOutTime","children":[{"text":""}]},{"text":",8,\\"小时\\")"}]}]', 'addTime(日报记录.班次下班时间, 8, "小时") ', '日报记录.班次下班时间 = 2022-01-01 18:00:00 返回：2022-01-02 02:00:00', '常用函数', 'constant', 999, 1000, 1);  INSERT INTO hcm_abs_overtime_formula_function ( value, field_label, meaning, param_explanation, example, example_text, result, group_name, group_biz, sort, group_sort, version) VALUES ( 'minusTime()', 'minusTime()', '获取指定时间增加指定时长后的时间', 'minusTime（指定时间, 数字 , "单位"） 指定时间：必填，填入指定时间，指定时间参数支持到秒 数字：需为整数 单位：支持年、月、日、小时、分钟', '[{"type":"paragraph","children":[{"text":"minusTime("},{"type":"tag","tagType":"fields","character":"日报记录.班次下班时间","id":"dailyReport#shiftOutTime","children":[{"text":""}]},{"text":",8,\\"小时\\")"}]}]', 'minusTime(日报记录.班次下班时间, 8, "小时") ', '日报记录.班次下班时间 = 2022-01-01 18:00:00 返回：2022-01-02 02:00:00', '常用函数', 'constant', 999, 1000, 1);    
  
  -- 月报统计 report_formula_function --  
  INSERT INTO hcm_abs_report_formula_function ( value, field_label, meaning, param_explanation, example, example_text, result, group_name, group_biz, sort, group_sort, version) VALUES ( 'addTime()', 'addTime()', '获取指定时间增加指定时长后的时间', 'addTime（指定时间, 数字 , "单位"） 指定时间：必填，填入指定时间，指定时间参数支持到秒 数字：需为整数 单位：支持年、月、日、小时、分钟', '[{"type":"paragraph","children":[{"text":"addTime("},{"type":"tag","tagType":"fields","character":"日报记录.班次下班时间","id":"dailyReport#shiftOutTime","children":[{"text":""}]},{"text":",8,\\"小时\\")"}]}]', 'addTime(日报记录.班次下班时间, 8, "小时") ', '日报记录.班次下班时间 = 2022-01-01 18:00:00 返回：2022-01-02 02:00:00', '常用函数', 'constant', 999, 1000, 1);  INSERT INTO hcm_abs_report_formula_function ( value, field_label, meaning, param_explanation, example, example_text, result, group_name, group_biz, sort, group_sort, version) VALUES ( 'minusTime()', 'minusTime()', '获取指定时间增加指定时长后的时间', 'minusTime（指定时间, 数字 , "单位"） 指定时间：必填，填入指定时间，指定时间参数支持到秒 数字：需为整数 单位：支持年、月、日、小时、分钟', '[{"type":"paragraph","children":[{"text":"minusTime("},{"type":"tag","tagType":"fields","character":"日报记录.班次下班时间","id":"dailyReport#shiftOutTime","children":[{"text":""}]},{"text":",8,\\"小时\\")"}]}]', 'minusTime(日报记录.班次下班时间, 8, "小时") ', '日报记录.班次下班时间 = 2022-01-01 18:00:00 返回：2022-01-02 02:00:00', '常用函数', 'constant', 999, 1000, 1);   
  
  -- 自动发假 autojob_formula_function --  
  
  INSERT INTO hcm_abs_autojob_formula_function ( value, field_label, meaning, param_explanation, example, example_text, result, group_name, group_biz, sort, group_sort) VALUES ( 'addTime()', 'addTime()', '获取指定时间增加指定时长后的时间', 'addTime（指定时间, 数字 , "单位"） 指定时间：必填，填入指定时间，指定时间参数支持到秒 数字：需为整数 单位：支持年、月、日、小时、分钟', '[{"type":"paragraph","children":[{"text":"addTime("},{"type":"tag","tagType":"fields","character":"日报记录.班次下班时间","id":"dailyReport#shiftOutTime","children":[{"text":""}]},{"text":",8,\\"小时\\")"}]}]', 'addTime(日报记录.班次下班时间, 8, "小时") ', '日报记录.班次下班时间 = 2022-01-01 18:00:00 返回：2022-01-02 02:00:00', '常用函数', 'constant', 999, 1000);  INSERT INTO hcm_abs_autojob_formula_function ( value, field_label, meaning, param_explanation, example, example_text, result, group_name, group_biz, sort, group_sort) VALUES ( 'minusTime()', 'minusTime()', '获取指定时间增加指定时长后的时间', 'minusTime（指定时间, 数字 , "单位"） 指定时间：必填，填入指定时间，指定时间参数支持到秒 数字：需为整数 单位：支持年、月、日、小时、分钟', '[{"type":"paragraph","children":[{"text":"minusTime("},{"type":"tag","tagType":"fields","character":"日报记录.班次下班时间","id":"dailyReport#shiftOutTime","children":[{"text":""}]},{"text":",8,\\"小时\\")"}]}]', 'minusTime(日报记录.班次下班时间, 8, "小时") ', '日报记录.班次下班时间 = 2022-01-01 18:00:00 返回：2022-01-02 02:00:00', '常用函数', 'constant', 999, 1000);
```







其次，**针对原有的****TimeAdd（变更为addDate）、TimeMinus（变更为minusDate）**：

```sql
/* 更新原TimeAdd、 TimeMinus函数 */ 

-- 加班 overtime_formula_function --

UPDATE hcm_abs_overtime_formula_function SET value = 'addDate()', field_label = 'addDate()', example = '[{"text":"addDate("},{"type":"tag","tagType":"fields","character":"任职信息.入职日期","id":"vacation_plan#current_period_end","children":[{"text":""}]},{"text":",3,\\"月\\")"}]', example_text = 'addDate(任职信息.入职日期, 3, "月")' WHERE value = 'TimeAdd()';  UPDATE hcm_abs_overtime_formula_function SET value = 'minusDate()', field_label = 'minusDate()', example = '[{"text":"minusDate("},{"type":"tag","tagType":"fields","character":"发假字段.当前周期结束日期","id":"vacation_plan#current_period_end","children":[{"text":""}]},{"text":",3,\\"月\\")"}]', example_text = 'minusDate(当前周期结束日期, 3 , "月")' WHERE value = 'TimeMinus()'; 

-- 月报统计 report_formula_function -- 

UPDATE hcm_abs_report_formula_function SET value = 'addDate()', field_label = 'addDate()', example = '[{"text":"addDate("},{"type":"tag","tagType":"fields","character":"任职信息.入职日期","id":"vacation_plan#current_period_end","children":[{"text":""}]},{"text":",3,\\"月\\")"}]', example_text = 'addDate(任职信息.入职日期, 3, "月")' WHERE value = 'TimeAdd()';  UPDATE hcm_abs_report_formula_function SET value = 'minusDate()', field_label = 'minusDate()', example = '[{"text":"minusDate("},{"type":"tag","tagType":"fields","character":"发假字段.当前周期结束日期","id":"vacation_plan#current_period_end","children":[{"text":""}]},{"text":",3,\\"月\\")"}]', example_text = 'minusDate(当前周期结束日期, 3 , "月")' WHERE value = 'TimeMinus()';  

-- 自动发假 autojob_formula_function --

UPDATE hcm_abs_autojob_formula_function SET value = 'addDate()', field_label = 'addDate()', example = '[{"text":"addDate("},{"type":"tag","tagType":"fields","character":"任职信息.入职日期","id":"vacation_plan#current_period_end","children":[{"text":""}]},{"text":",3,\\"月\\")"}]', example_text = 'addDate(任职信息.入职日期, 3, "月")' WHERE value = 'TimeAdd()';  UPDATE hcm_abs_autojob_formula_function SET value = 'minusDate()', field_label = 'minusDate()', example = '[{"text":"minusDate("},{"type":"tag","tagType":"fields","character":"发假字段.当前周期结束日期","id":"vacation_plan#current_period_end","children":[{"text":""}]},{"text":",3,\\"月\\")"}]', example_text = 'minusDate(当前周期结束日期, 3 , "月")' WHERE value = 'TimeMinus()';   
```





同理，下列两个接口对应的表数据也做同样的修改

- 假期规则设置-休假规则-编辑-发假规则的自定义公式 ——— hcm_abs_autojob_formula_function
- 加班规则设置-加班类型编辑-调休假补偿时长的自定义公式———hcm_abs_overtime_formula_function





逻辑改动：

以 考勤统计设置-字段设置为例：

 由于addDate、minusDate、addTime、minusDate均为常用函数，隶属于hcm-formula模块，被其他模块（hcm-absence-account、hcm-absence-statistics）引入，在设置了需要使用自定义函数公式计算的字段后，此时若进行出勤月报、出勤日报的重新核算  /api/absence-statistics/v1/report/month/reCalculate  ， 流程如下：

![image-20231107155111841](https://cdn.jsdelivr.net/gh/amonstercat/PicGo/202312211706087.png)

因此需要针对DateHelper类下的自定义函数进行改动：

- addTime（指定时间, 数字 , "单位"） 其中：指定时间：必填，填入指定时间；指定时间参数支持到秒 (2022-01-01 18:00)；单位：支持年、月、日、小时、分钟

​     示例1：addTime(日报记录.班次下班时间, 2, "小时")  日报记录.班次下班时间 = 2022-01-01 18:00:00    返回：2022-01-01 20:00:00

​     示例2: addTime(日报记录.班次下班时间, 2, "小时")  日报记录.班次下班时间 = 2022-01-01 18:00       返回：2022-01-01 20:00:00

​     示例3: addTime(日报记录.班次下班时间, 2, "日")    日报记录.班次下班时间 = 2022-01-01 18:00       返回：2022-01-03 18:00:00

- addDate（指定时间, 数字 , "单位"） 其中：指定时间：必填，填入指定日期（2022-08-01）； 单位：支持年、月、日

​     示例：addDate(任职信息.入职日期, 3, "月")  任职信息.入职日期 = 2022-01-01   返回：2022-04-01

- minusTime、minusDate 的实现类似

同时借助QLExpression将这些自定义函数注册到程序中：

```java
//----
addFunctionOfClassMethod("addTime", DateHelper.class, "timeAdd", new Class[]{String.class, Integer.class , Object.class}, null);
addFunctionOfClassMethod("minusTime", DateHelper.class, "timeMinus", new Class[]{String.class, Integer.class ,Object.class}, null);
addFunctionOfClassMethod("addDate", DateHelper.class, "dateAdd", new Class[]{String.class, Integer.class ,Object.class}, null);
addFunctionOfClassMethod("minusDate", DateHelper.class, "dateMinus", new Class[]{String.class, Integer.class ,Object.class}, null);
//----
```



四、涉及到的数据清洗

考虑到原自定义函数公式表中可能引用了旧的公式，因此需要对涉及到旧公式的三张表进行清洗，即将原表中包含 "TimeAdd"、"TimeMinus" 字符的字段分别变更为"addDate"、"minusDate"



-- 月报统计函数、公式
hcm_abs_report_formula_function
hcm_abs_report_month_field

清洗旧公式的接口路径为 **hcm-absence-statistics** 下：





## formula变更

 未完待续。。。









## 涉及到的数据清洗



未完待续。。。











# 新增 统计指定时间内出勤时长业务函数



## 需求说明

根据需求文档中的说明来看，事件参数有三种类型：

| 函数                         | 可用          | 说明                                                         | 示例                                                         | 应用场景                               |
| :--------------------------- | :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- | :------------------------------------- |
| 取指定时间内的出勤事件时长() | 按天/按月统计 | 函数说明 支持指定时间范围内，**外出/出差/请假的时长交集**  参数说明 取指定时间内的时长交集(开始时间, 结束时间, "参数1" , "单位"）参数1：必填，填入**外出/出差/请假**单位：天、小时、分钟 | 取指定时间内的时长交集(日报记录.上班打卡时间, 日报记录.下班打卡时间, “外出” , "小时")  日报记录.上班打卡时间 = 2023-10-10 08:56:00日报记录.下班打卡时间 = 2023-10-10 18:20:00当天外出有2条记录： 2023-10-10 09:00:00 ~ 2023-10-10 12:00:00， 2023-10-10 17:00:00 ~ 2023-10-10 20:00:00  返回：**4.3333** | 用于统计有外出、出差、请假时的有效工时 |



> 4.3333如何计算出来的:grey_question:
>
> 
>
> 这里的出勤时长实际上指的是工作时间内的**外出/请假/出差**事件时长：
>
> 
> 在这个例子中，上班打卡时间是 2023-10-10 08:56:00，下班打卡时间是 2023-10-10 18:20:00。
>
> 外出记录有两条：
>
> - 外出记录1: 2023-10-10 09:00:00 到 2023-10-10 12:00:00
> - 外出记录2: 2023-10-10 17:00:00 到 2023-10-10 20:00:00
>
> 计算交集时长：
>
> 1. 2023-10-10 09:00:00 到 2023-10-10 12:00:00 与上班打卡时间到下班打卡时间的交集为 09:00:00 到 12:00:00，交集时长为 3 小时。
> 2. 2023-10-10 17:00:00 到 2023-10-10 18:20:00 与上班打卡时间到下班打卡时间的交集为 17:00:00 到 18:20:00，交集时长为 1 小时 20 分钟。
>
> 总的时长交集为 3 小时 + 1 小时 20 分钟 = 4 小时 20 分钟 = 4.3333 小时
>
> 
>
> 
>
> 看图更直观一些： 黄色区间为==[上班打卡时间、下班打卡时间]==，蓝色区间为==总的时长交集==
>
> ![image2023-11-1_20-55-46](https://cdn.jsdelivr.net/gh/amonstercat/PicGo/202312211434947.png)





在假勤设置—考勤统计设置—月报名称—设置字段—添加自定义字段内，可以对自定义字段来设置公式：

![image-20231221141927611](https://cdn.jsdelivr.net/gh/amonstercat/PicGo/202312211419635.png)

进入公式编辑后：

![image-20231221141716412](https://cdn.jsdelivr.net/gh/amonstercat/PicGo/202312211417459.png)







## 自定义员工出勤时间段内事件信息类

`AttendanceTimePeriodInfo` 类：表示员工的出勤时间段信息的主要类。

- `leavePeriods`：存储请假时段的列表。
- `outPeriods`：存储外出时段的列表。
- `tirpPeriods`：存储出差时段的列表。

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AttendanceTimePeriodInfo {

    /**
     * 请假时段
     */
    private List<TimePeriod> leavePeriods;

    /**
     * 外出时段
     */
    private List<TimePeriod> outPeriods;

    /**
     * 出差时段
     */
    private List<TimePeriod> tirpPeriods;


    private Long employeeId;

    private Long entId;


    public void parseLeaveInfo(List<ReportLeaveDataDto> leaveDataList){
        if(CollectionUtils.isEmpty(leaveDataList)){
            return;
        }
        leavePeriods = new ArrayList<>();
        leaveDataList.forEach(leaveData -> {
            leavePeriods.add(TimePeriod.builder().beginTime(leaveData.getBeginTime()).endTime(leaveData.getEndTime()).build());
        });
    }

    public void parseOutInfo(List<AbsReportOutTripDataDto> outDataList){
        if(CollectionUtils.isEmpty(outDataList)){
            return;
        }
        outPeriods = new ArrayList<>();
        outDataList.forEach(outData -> {
            outPeriods.add(TimePeriod.builder().beginTime(outData.getBeginTime()).endTime(outData.getEndTime()).build());
        });
    }

    public void parseTripInfo(List<AbsReportBusinessTripDataDto> tripDataList){
        if(CollectionUtils.isEmpty(tripDataList)){
            return;
        }
        tirpPeriods = new ArrayList<>();
        tripDataList.forEach(tripData -> {
            tirpPeriods.add(TimePeriod.builder().beginTime(tripData.getBeginTime()).endTime(tripData.getEndTime()).build());
        });
    }


    /**
     * 取指定事件类型的出勤时间段
     * @param eventType
     * @return
     */
    public List<TimePeriod> getAttendanceTimePeriods(String eventType){
        if(eventType.equals(AttendanceLengthOfTime.EVENT_TYPE_LEAVE)){
            return leavePeriods;
        }else if(eventType.equals(AttendanceLengthOfTime.EVENT_TYPE_OUT)){
            return outPeriods;
        }else if(eventType.equals(AttendanceLengthOfTime.EVENT_TYPE_TRIP)){
            return tirpPeriods;
        }
        return null;
    }


    @Data
    @Builder
    public static class TimePeriod{

        private Date beginTime;

        private Date endTime;

        public Period<Minute> toMinutePeriod(){
            return Period.betweenMinutes(beginTime,endTime);
        }

        public static TimePeriod from(LocalDateTime start,LocalDateTime end){
            return TimePeriod.builder()
                    .beginTime(Date.from(start.atZone(ZoneId.systemDefault()).toInstant()))
                    .endTime(Date.from(end.atZone(ZoneId.systemDefault()).toInstant()))
                    .build();
        }
    }

}

```

其中：

- `parseLeaveInfo`：解析请假信息，将请假数据列表转换为请假时段列表。
- `parseOutInfo`：解析外出信息，将外出数据列表转换为外出时段列表。
- `parseTripInfo`：解析出差信息，将出差数据列表转换为出差时段列表。
- `getAttendanceTimePeriods`：根据指定的事件类型返回相应的出勤时间段列表。



为什么要进行列表转换呢？

以请假数据为例：这是为了将外部传入的数据格式（`List<ReportLeaveDataDto>`）转换成内部更方便处理的数据结构（`List<TimePeriod>`）。在这里，`ReportLeaveDataDto` 是外部传入的请假数据的对象，而 `TimePeriod` 是内部表示时间段的对象，即仅将**`ReportLeaveDataDto`**所需要的`beginWorkTime`(外出开始时间)、`endWorkTime`(外出结束时间)封装至`leavePeriods`（List<TimePeriod>）





## RPC获取员工班次数据

首先需要明确一点，该员工当天的外出、请假、出差事件是和该员工所属租户下的班次所关联的，因此需要先获取该租户下的班次信息 ：

ShiftAdapterImpl.java

```java
@Override
public List<ShiftRecordApiDto> getAllShiftList(Long entId, Long buId){
    ShiftReqApiDto reqApiDto = ShiftReqApiDto.builder().entId(entId).buId(buId).build();
    reqApiDto.setPageNum(1);
    reqApiDto.setPageSize(Integer.MAX_VALUE);
    SingleResultDto<PageInfoDto<ShiftRecordApiDto>> resultDto = shiftClient.selectShiftApiList(reqApiDto);

    if (Objects.isNull(resultDto) || !resultDto.success() || Objects.isNull(resultDto.getData()) || Objects.isNull(resultDto.getData().getList())) {
        log.info("查询租户所有班次异常， param = {}, entId = {}, buId = {}， result:{}", reqApiDto, entId, buId, resultDto);
        throw new CustomException(ErrorCodeEnum.SERVER_INTERVAL_ERROR);
    }
    return resultDto.getData().getList();
}
```



ShiftClient.java：

```java
@FeignClient(
        name = "hcm-absence",
        url = "${custom.service.url.hcm-absence:}",
        fallbackFactory = ShiftFallback.class
)
public interface ShiftClient {

    /**
     * 查询班次详情
     * @param param
     * @param entId
     * @param buId
     * @return
     */
    @PostMapping("/client/absence/v1/abs/shift/getShiftDetailList")
    SingleResultDto<ShiftSearchResultDto> getShiftDetailList(@RequestBody ShiftSearchParamDto param, @RequestParam("entId") Long entId, @RequestParam("buId") Long buId);


    /**
     * 查询班次信息
     * @param paramDto
     * @return
     */
    @PostMapping("/client/absence/v2/abs/shift/selectShiftApiList")
    SingleResultDto<PageInfoDto<ShiftRecordApiDto>> selectShiftApiList(@RequestBody ShiftReqApiDto paramDto);
}

```











## 构建日报公式上下文数据 :star2:



### `ContextBuilderUtils`

```java
  public class ContextBuilderUtils {


public static List<EmployeeContext> getDailyReportEmployeeContextList(List<FieldNameFormulaDto> defFormulaList,DailyReportCalculateWrapperBo dailyReportCalculateWrapperBo){
        List<EmployeeContext> contextList = new ArrayList<>();

        Map<String, DailyReportAggregationBo> dailyReportBoMap = dailyReportCalculateWrapperBo.getDailyReportAggregationMap();
        if(CollUtil.isEmpty(dailyReportBoMap)){
            log.info("无日报数据:{}",dailyReportCalculateWrapperBo);
            return contextList;
        }
        StopWatch stopWatch = new StopWatch("构建日报公式上下文数据");
      
      
        //租户维度的上下文数据
        Map<String,Object> entContextDatas = new HashMap<>();
      
      
        //员工维度的上下文数据，初始化租户和员工维度的上下文数据容器：
        Map<Long,Map<String,Object>> employeeContextDatas = new HashMap<>();

        Long entId = dailyReportCalculateWrapperBo.getEntId(),buId = dailyReportCalculateWrapperBo.getBuId();
        List<Long> employeeIds = dailyReportCalculateWrapperBo.getEmployeeIdList();

        //员工属性builder
        /*
         * 获取员工属性数据： 使用 HrFieldBuilder 从数据库中获取员工属性数据，
           包括员工ID、企业ID、部门ID、生效日期、失效日期等信息。
         */
        stopWatch.start("查询员工属性字段");
        HrFieldBuilder hrFieldBuilder = SpringContextUtils.getBean(HrFieldBuilder.class);
        Map<Long,List<EmployeeChangeAttributes>> employeeChangeAttrs = hrFieldBuilder.getEmployeeChangeAttributes(entId,buId,employeeIds,dailyReportCalculateWrapperBo.getBeginDate(),dailyReportCalculateWrapperBo.getEndDate());
        stopWatch.stop();


        //日报数据builder
        /*
         *初始化日报数据构建器： 使用 DailyReportAttendanceRecordBuilder 初始化日报数据构建器，
         *并设置租户和部门信息。
        */
        stopWatch.start("日报builder初始化");
        DailyReportAttendanceRecordBuilder dailyReportBuilder = new DailyReportAttendanceRecordBuilder( true);
        dailyReportBuilder.initEntInfo(dailyReportCalculateWrapperBo.getEntId(),dailyReportCalculateWrapperBo.getBuId());
        stopWatch.stop();

        //可选上下文标识
        Map<String,Boolean> contextFlags = getDailyReportContextFlags(defFormulaList);

        if(contextFlags.getOrDefault(AttendanceCalendarDays.NAME,false)){
            //公式中有假勤日历天数函数，需要取相关上下文数据
            stopWatch.start("查询出勤日历数据");
            AttendanceCalendarDaysBuilder attendanceCalendarDaysBuilder = SpringContextUtils.getBean(AttendanceCalendarDaysBuilder.class);
            Map<Long,Map<String,Object>> calendarData = attendanceCalendarDaysBuilder.getEmployeeCalendars(employeeIds,entId,buId);
            mergeMap(calendarData,employeeContextDatas);
            stopWatch.stop();
        }
//        if(contextFlags.getOrDefault(DepartmentAttribution.NAME,false)){
//            //取部门全路径
//            AffiliationDepartmentBuilder affiliationDepartmentBuilder = SpringContextUtils.getBean(AffiliationDepartmentBuilder.class);
//            Map<Long,Map<String,Object>> departPathDatas = affiliationDepartmentBuilder.getEmployeeDepartPath(employeeIds,entId,buId);
//            mergeMap(departPathDatas,employeeContextDatas);
//        }
        if(contextFlags.getOrDefault(StandardCalendarDays.NAME,false)){
            //标准日历
            stopWatch.start("查询标准日历数据");
            AttendanceStandardBuilder standardCalendarBuilder = SpringContextUtils.getBean(AttendanceStandardBuilder.class);
            Map<String,Object> calendarData = standardCalendarBuilder.getEntStandarCalendar(entId,buId);
            entContextDatas.putAll(calendarData);
            stopWatch.stop();
        }

        if(contextFlags.getOrDefault(AttendanceLengthOfTime.NAME,false)){
            //出勤记录时段信息
            stopWatch.start("出勤记录时段信息");
            AttendanceLengthOfTimeBuilder attendanceLengthOfTimeBuilder = SpringContextUtils.getBean(AttendanceLengthOfTimeBuilder.class);
            Map<Long,Map<String,Object>> empAttendanceTimeMap = attendanceLengthOfTimeBuilder.getEmployeeAttendanceInfos(employeeIds,dailyReportCalculateWrapperBo.getBeginDate().toDate(),dailyReportCalculateWrapperBo.getEndDate().toDate(),entId,buId);

            for(Long employeeId:empAttendanceTimeMap.keySet()){
                Map<String,Object> map = employeeContextDatas.getOrDefault(employeeId,new HashMap<>());
                if(MapUtils.isEmpty(map)){
                    employeeContextDatas.put(employeeId,map);
                }
                map.putAll(empAttendanceTimeMap.get(employeeId));
            }

            //设置班次休息时间，不放到上下文中
            ShiftRestTimeBuilder shiftRestTimeBuilder = SpringContextUtils.getBean(ShiftRestTimeBuilder.class);
            shiftRestTimeBuilder.setEntShiftRestTimes(entId,buId);
            stopWatch.stop();
        }

        stopWatch.start("日报字段构建");
        dailyReportBoMap.values().forEach(aggregationBo -> {
            DailyReportBo dailyReport = aggregationBo.getDailyReport();
            Long employeeId = dailyReport.getEmployeeId();
            Date calculateDate = dailyReport.getDailyReportDate();

            //日报数据构造上下文
            EmployeeContext employeeContext = dailyReportBuilder.buildEmployeeContext(DailyReportFormulaFieldContextWrapperBo.builder()
                    .employeeId(employeeId)
                    .calculateDate(calculateDate)
                    .dailyReportAggregationBo(aggregationBo)
                    .build());

            //取出员工维度的上下文数据放到employeeContext中
            Map<String, Object> contextDataMap = employeeContext.getContext();
            contextDataMap.putAll(entContextDatas);
            contextDataMap.putAll(employeeContextDatas.getOrDefault(employeeId,new HashMap<>()));

            //员工字段信息
            contextDataMap.putAll(getEmployeeAttrsWithDate(calculateDate,employeeChangeAttrs.get(employeeId)));
            contextList.add(employeeContext);
        });
        stopWatch.stop();

        log.info("日报上下文公式构建耗时，租户：{},{}",entId,stopWatch.prettyPrint());
        return contextList;
    }

    
  }
```





注意看这一段逻辑：

如果日报字段的公式中包含了 `AttendanceLengthOfTime` 函数，表示需要构建出勤记录时段信息的上下文。

```java
if(contextFlags.getOrDefault(AttendanceLengthOfTime.NAME,false)){
    //出勤记录时段信息
    stopWatch.start("出勤记录时段信息");
    AttendanceLengthOfTimeBuilder attendanceLengthOfTimeBuilder = SpringContextUtils.getBean(AttendanceLengthOfTimeBuilder.class);
    Map<Long,Map<String,Object>> empAttendanceTimeMap = attendanceLengthOfTimeBuilder.getEmployeeAttendanceInfos(employeeIds,dailyReportCalculateWrapperBo.getBeginDate().toDate(),dailyReportCalculateWrapperBo.getEndDate().toDate(),entId,buId);

    for(Long employeeId:empAttendanceTimeMap.keySet()){
        Map<String,Object> map = employeeContextDatas.getOrDefault(employeeId,new HashMap<>());
        if(MapUtils.isEmpty(map)){
            employeeContextDatas.put(employeeId,map);
        }
        map.putAll(empAttendanceTimeMap.get(employeeId));
    }

    //设置班次休息时间，不放到上下文中
    ShiftRestTimeBuilder shiftRestTimeBuilder = SpringContextUtils.getBean(ShiftRestTimeBuilder.class);
    shiftRestTimeBuilder.setEntShiftRestTimes(entId,buId);
    stopWatch.stop();
}
```

可以看出来，使用 `AttendanceLengthOfTimeBuilder` 获取员工的出勤记录时段信息，该信息是一个映射，其中键是员工ID，值是包含出勤记录时段信息的 Map



### `AttendanceLengthOfTimeBuilder`

然后我们重点来看一下这个**`builder`**:

```java
@Service
public class AttendanceLengthOfTimeBuilder extends ContextBuilderSource {


    public static final String CONTEXT_KEY = "attendanceTimePeriods";

    @Resource
    private ReportLeaveDataAdapter reportLeaveDataAdapter;

    @Resource
    private OutTripAdapter outTripAdapter;

    @Resource
    private BusinessTripAdapter businessTripAdapter;

    @Override
    public List<EmployeeContext> build(List<Long> employeeIdList, Long entId, Long buId, Object... other) {
        //未使用的方法
        List<EmployeeContext> result = Lists.newArrayList();
        return result;
    }

    /**
     * 查询员工出勤记录信息
     * @param employeeIdList
     * @param start
     * @param end
     * @param entId
     * @param buId
     * @return
     */
    public Map<Long, Map<String,Object>> getEmployeeAttendanceInfos(List<Long> employeeIdList,
                                                                    Date start,
                                                                    Date end,
                                                                    Long entId,
                                                                    Long buId){

        checkParam(employeeIdList, entId, buId);

        //把日期向前推一天，向后推1天，查请假、出差、外出拆分表数据
        start = DateUtils.addDay(start,-1);
        end = DateUtils.addDay(end,1);

        //请假记录
        Map<Long, List<ReportLeaveDataDto>> empLeaveMap = reportLeaveDataAdapter.getLeaveRecordForDay(entId, buId, employeeIdList, start, end);

        //外出记录
        List<AbsReportOutTripDataDto> outList = outTripAdapter.list(entId, buId, start, end, employeeIdList);
        Map<Long, List<AbsReportOutTripDataDto>> empOutMap = outList.stream().collect(Collectors.groupingBy(AbsReportOutTripDataDto::getEmployeeId));

        //出差记录
        List<AbsReportBusinessTripDataDto> tripList = businessTripAdapter.list(entId, buId, start, end, employeeIdList);
        Map<Long, List<AbsReportBusinessTripDataDto>> empTripMap = tripList.stream().collect(Collectors.groupingBy(AbsReportBusinessTripDataDto::getEmployeeId));

        Map<Long,Map<String,Object>> result = new HashMap<>();
        for (Long employeeId : employeeIdList) {
            Map<String, Object> context = new HashMap<>();
            AttendanceTimePeriodInfo attendanceTimePeriodInfo = new AttendanceTimePeriodInfo();
            attendanceTimePeriodInfo.setEmployeeId(employeeId);
            attendanceTimePeriodInfo.setEntId(entId);
            attendanceTimePeriodInfo.parseLeaveInfo(empLeaveMap.get(employeeId));
            attendanceTimePeriodInfo.parseOutInfo(empOutMap.get(employeeId));
            attendanceTimePeriodInfo.parseTripInfo(empTripMap.get(employeeId));
            context.put(CONTEXT_KEY,attendanceTimePeriodInfo);
            result.put(employeeId,context);
        }
        return result;
    }
}
```

主要做了几件事：

- 获取员工的请假记录、外出记录和出差记录。

- 将请假、外出和出差记录按员工ID进行分组。
- 构建结果的 `Map`，其中键是员工ID，值是包含出勤记录时段信息的 `Map`。
- 将结果封装到 `AttendanceTimePeriodInfo` 中，并放入上下文中。







### `ShiftRestTimeBuilder`

`ShiftRestTimeBuilder`用于构建租户级别的班次休息时间上下文

```java
/**
 * 租户级别的数据，理论上不需要每个员工上下文都保存一份，如果量不大，直接放到静态map中只存一份，效率更高
 */
@Service
public class ShiftRestTimeBuilder extends ContextBuilderSource {

    public static Map<Long,Map<Long,List<ShiftTimesApiDto>>> entShiftRestTimes = new ConcurrentHashMap<>();

    public static final int TYPE_REST_TIME = 2;

    @Resource
    private ShiftAdapter shiftAdapter;


    @Override
    public List<EmployeeContext> build(List<Long> employeeIdList, Long entId, Long buId, Object... other) {
        //未使用的方法
        List<EmployeeContext> result = Lists.newArrayList();
        return result;
    }

    /**
     * 设置租户班次休息时间
     * @param entId
     * @param buId
     * @return
     */
    public void setEntShiftRestTimes(Long entId, Long buId){
        List<ShiftRecordApiDto> shiftList = shiftAdapter.getAllShiftList(entId,buId);
        if(CollectionUtils.isEmpty(shiftList)){
            return;
        }
        Map<Long,List<ShiftTimesApiDto>> restMap = new HashMap<>();
        shiftList.forEach(shift -> {
            List<ShiftTimesApiDto> shiftTimes = shift.getShiftTimesList();
            if(CollectionUtils.isEmpty(shiftTimes)){
                return;
            }
            shiftTimes = shiftTimes.stream().filter(shiftTime -> Objects.nonNull(shiftTime.getSectionType()) && TYPE_REST_TIME == shiftTime.getSectionType()).collect(Collectors.toList());
            if(CollectionUtils.isNotEmpty(shiftTimes)){
                restMap.put(shift.getShiftId(),shiftTimes);
            }
        });

        entShiftRestTimes.put(entId,restMap);
    }
}

```

这个方法用于设置租户级别的班次休息时间。具体步骤如下：

- 通过 `ShiftAdapter` 获取指定租户和业务单元下的所有班次信息。
- 遍历班次列表，筛选出每个班次的休息时间信息，并将其存储在 `shiftTimes` 列表中。
- 构建 `restMap`，其中的键是班次ID，值是该班次对应的休息时间列表。
- 将 `restMap` 存储到 `entShiftRestTimes` 中，以租户ID作为键。

这个类的主要作用是维护租户级别的班次休息时间信息，提供了一个静态的存储结构 `entShiftRestTimes` 以供全局访问。





那么为什么需要这个班次休息时间的`Builder`呢？

`AttendanceLengthOfTimeBuilder` 中的 `getEmployeeAttendanceInfos` 方法使用了 `ShiftRestTimeBuilder`。

在这个方法中，首先通过 `reportLeaveDataAdapter`、`outTripAdapter` 和 `businessTripAdapter` 分别获取了员工的请假记录、外出记录和出差记录。然后，通过 `ShiftRestTimeBuilder` 中的 `entShiftRestTimes` 获取了班次休息时间信息。







## 核心逻辑 :exclamation:

```java
/**
 * 计算指定事件和时间范围内的出勤时长
 */
@Slf4j
public class AttendanceLengthOfTime extends CustomFunction {


    public static final String NAME = "取指定时间内的出勤事件时长";

    private static final String ERR_MEG = "创建" + NAME + "失败";

    public static final String EVENT_TYPE_LEAVE = "请假";
    public static final String EVENT_TYPE_OUT = "外出";
    public static final String EVENT_TYPE_TRIP = "出差";

    public static final String UNIT_HOUR = "小时";
    public static final String UNIT_MINUTE = "分钟";

    public static final String YES = "是";

    public static final String NO = "否";


    public static void main(String[] args) {
        //构建出勤数据
        AttendanceTimePeriodInfo attendanceTimePeriodInfo = new AttendanceTimePeriodInfo();
        List<AttendanceTimePeriodInfo.TimePeriod> leavePeriods = new LinkedList<>();
        leavePeriods.add(AttendanceTimePeriodInfo.TimePeriod.builder()
                .beginTime(DateUtils.parse("2023-11-01 08:00:00",DatePattern.YMDHMS))
                .endTime(DateUtils.parse("2023-11-01 10:00:00",DatePattern.YMDHMS)).build());
        leavePeriods.add(AttendanceTimePeriodInfo.TimePeriod.builder()
                .beginTime(DateUtils.parse("2023-11-01 08:00:00",DatePattern.YMDHMS))
                .endTime(DateUtils.parse("2023-11-01 11:30:00",DatePattern.YMDHMS)).build());
        attendanceTimePeriodInfo.setLeavePeriods(leavePeriods);

        //计算值
        AttendanceLengthOfTime attendanceLengthOfTime = new AttendanceLengthOfTime();
        QlExpressContext expressContext = new QlExpressContext();
        expressContext.put(AttendanceLengthOfTimeBuilder.CONTEXT_KEY,attendanceTimePeriodInfo);
        attendanceLengthOfTime.setExpressContext(expressContext);
        System.out.println(attendanceLengthOfTime.calculate("2023-11-01 08:00:00","2023-11-01 11:40:00","请假","分钟","是"));
    }

    @CustomFunctionMethod(id = NAME, name = NAME, returnType = FunctionType.NUMBER, errorInfo = ERR_MEG, paramCustomType = {FunctionType.DATE,FunctionType.DATE,FunctionType.STRING,FunctionType.STRING,FunctionType.STRING})
    public Double calculate(String startTime,String endTime,String eventType,String unit,String excludeRestStr) {
        log.debug("AttendanceLengthOfTime：startTime:{},endTime:{},eventType:{},unit:{}",startTime,endTime,eventType,unit);
        if(StringUtils.isEmpty(startTime) || StringUtils.isEmpty(endTime) || StringUtils.isEmpty(eventType) || StringUtils.isEmpty(unit) || StringUtils.isEmpty(excludeRestStr)){
            //算不出来，返回0
            return 0d;
        }
        // 获取上下文
        AttendanceTimePeriodInfo attendanceTimePeriodInfo = (AttendanceTimePeriodInfo) getContext().get(AttendanceLengthOfTimeBuilder.CONTEXT_KEY);
        if(Objects.isNull(attendanceTimePeriodInfo)){
            return 0d;
        }

        boolean excludeRest = excludeRestStr.equals(YES);
        try {
            LocalDateTime start = DateHelper.getDateTimeByStr(startTime);
            LocalDateTime end = DateHelper.getDateTimeByStr(endTime);

            List<AttendanceTimePeriodInfo.TimePeriod> attendancePeriods = attendanceTimePeriodInfo.getAttendanceTimePeriods(eventType);

            List<Period<Minute>> effectPeriods = this.getIntersect(attendanceTimePeriodInfo.getEntId(),AttendanceTimePeriodInfo.TimePeriod.from(start,end), attendancePeriods,excludeRest);
            BigDecimal lengthOfTime = this.getLengthOfTime(effectPeriods,unit);
            return Double.valueOf(lengthOfTime.stripTrailingZeros().toPlainString());
        }catch (Exception e){
            log.warn("函数{}计算出错，employeeId:{},startTime:{},endTime:{},eventType:{},unit:{},exMsg:{}",attendanceTimePeriodInfo.getEmployeeId(),NAME,startTime,endTime,eventType,unit,e.getMessage());
        }
        return 0d;
    }

    private List<Period<Minute>> getRestPeriods(Long entId){
        String shiftIdKey = "dailyReport#"+ DailyConstant.COLUMN_SHIFT_ID;
        Object value = getContext().get(shiftIdKey);
        if(Objects.isNull(value)){
            return new ArrayList<>();
        }
        Long shiftId = Long.parseLong(value.toString());
        if(shiftId == 0L){
            return new ArrayList<>();
        }
        Map<Long,List<ShiftTimesApiDto>> shiftRestTimeMap = ShiftRestTimeBuilder.entShiftRestTimes.get(entId);
        if(MapUtils.isEmpty(shiftRestTimeMap)){
            return new ArrayList<>();
        }

        List<ShiftTimesApiDto> shiftRestTimes = shiftRestTimeMap.get(shiftId);
        if(CollectionUtils.isEmpty(shiftRestTimes)){
            return new ArrayList<>();
        }

        //取日报记录当天
        String date = this.getContext().get("dailyReport#clockDate").toString();

        List<Period<Minute>> result = new ArrayList<>();
        shiftRestTimes.forEach(restTime -> {
            Date startTime = this.concatDateAndTime(date, restTime.getStartTime(),restTime.getStartDayType());
            Date endTime = this.concatDateAndTime(date, restTime.getEndTime(),restTime.getEndDayType());
            if(Objects.nonNull(startTime) && Objects.nonNull(endTime)){
                result.add(Period.betweenMinutes(startTime,endTime));
            }
        });
        return result;
    }

    private Date concatDateAndTime(String date,String time,Integer timeType){
        DayEnum dayEnum = DayEnum.parse(timeType);
        Date dateTime = com.moka.hcm.absence.common.utils.DateUtils.connectDateAndTime(date, time);
        if(Objects.isNull(dateTime)){
            return null;
        }
        if(dayEnum == DayEnum.CURRENT_DAY){
            return dateTime;
        }else if(dayEnum == DayEnum.PRE_DAY){
            return DateUtils.addDay(dateTime,-1);
        }else if(dayEnum == DayEnum.NEXT_DAY){
            return DateUtils.addDay(dateTime,1);
        }
        return dateTime;
    }

    /**
     * 计算时长
     * @param effectPeriods
     * @param unit
     * @return
     */
    private BigDecimal getLengthOfTime(List<Period<Minute>> effectPeriods, String unit){
        if(CollectionUtils.isEmpty(effectPeriods)){
            return BigDecimal.ZERO;
        }
        long allMinutes = 0;
        for(Period<Minute> period:effectPeriods){
            allMinutes += period.getInterval();
        }
        if(unit.equals(UNIT_HOUR)){
            return new BigDecimal(allMinutes).divide(new BigDecimal(60),4, RoundingMode.DOWN);
        }
        return new BigDecimal(allMinutes);
    }

    /**
     * 取指定范围和出勤事件时段交集范围
     * @param requestTimePeriod
     * @param attendanceTimePeriods
     * @param excludeRest
     * @return
     */
    private List<Period<Minute>> getIntersect(Long entId,AttendanceTimePeriodInfo.TimePeriod requestTimePeriod,List<AttendanceTimePeriodInfo.TimePeriod> attendanceTimePeriods,boolean excludeRest){
        if(CollectionUtils.isEmpty(attendanceTimePeriods)){
            return null;
        }
        List<Period<Minute>> requestPeriods = Arrays.asList(requestTimePeriod.toMinutePeriod());
        List<Period<Minute>> attendancePeriods = attendanceTimePeriods.stream().map(timePeriod -> timePeriod.toMinutePeriod()).collect(Collectors.toList());
        //取交集
        List<Period<Minute>> intersects =  this.intersectPeriods(requestPeriods,attendancePeriods);

        if(excludeRest){
            //排除休息时段
            List<Period<Minute>> restPeriods = this.getRestPeriods(entId);
            if(CollectionUtils.isNotEmpty(restPeriods)){
                intersects = this.removePeriods(intersects,restPeriods);
            }
        }
        //移出内部交集时段
        return this.removeInnerIntersects(intersects);
    }

    /**
     * 移出目标时段
     * @param srcPeriods
     * @param removePeriods
     * @return
     */
    private List<Period<Minute>> removePeriods(List<Period<Minute>> srcPeriods,List<Period<Minute>> removePeriods){
        if(CollectionUtils.isEmpty(srcPeriods) || CollectionUtils.isEmpty(removePeriods)){
            return srcPeriods;
        }
        List<Period<Minute>> result = new ArrayList<>();
        srcPeriods.forEach(srcPeriod -> {
            result.addAll(srcPeriod.remove(removePeriods));
        });
        return result;
    }

    /**
     * 移出内部互相交集的时段
     * @param periods
     * @return
     */
    private List<Period<Minute>> removeInnerIntersects(List<Period<Minute>> periods){
        if(CollectionUtils.isEmpty(periods)){
            return periods;
        }
        List<Period<Minute>> result = new ArrayList<>();

        //临时数组，用来作为被删除的时段
        List<Period<Minute>> tempList = new LinkedList<>();
        tempList.addAll(periods);

        for(int i=0;i<periods.size();i++){
            Period<Minute> src = periods.get(i);
            tempList.remove(0);
            List<Period<Minute>> retainPeriods = this.removePeriods(Arrays.asList(src),tempList);
            if(CollectionUtils.isNotEmpty(retainPeriods)){
                result.addAll(retainPeriods);
            }
        }
        return result;
    }

    /**
     * 取交集时段
     * @param srcPeriods
     * @param targetPeriods
     * @return
     */
    private List<Period<Minute>> intersectPeriods(List<Period<Minute>> srcPeriods,List<Period<Minute>> targetPeriods){
        if(CollectionUtils.isEmpty(srcPeriods) || CollectionUtils.isEmpty(targetPeriods)){
            return new ArrayList<>();
        }
        List<Period<Minute>> result = new ArrayList<>();
        srcPeriods.forEach(srcPeriod -> {
            targetPeriods.forEach(targetPeriod -> {
                Period<Minute> intersect = srcPeriod.intersect(targetPeriod);
                if(Objects.nonNull(intersect)){
                    result.add(intersect);
                }
            });
        });
        return result;
    }


    @Override
    public List<String> checkParam(FunctionParam[] types) {
        List<String> result = Lists.newArrayList();

        FunctionParam startTime = types[0];
        FunctionParam endTime = types[1];
        FunctionParam eventType = types[2];
        FunctionParam unit = types[3];
        FunctionParam excludeRest = types[4];

        if(!checkDate(startTime)){
            result.add(String.format("%s函数的第一个参数需要是日期类型",NAME));
        }
        if(!checkDate(endTime)){
            result.add(String.format("%s函数的第二个参数需要是日期类型",NAME));
        }
        if(!checkIn(eventType,EVENT_TYPE_OUT,EVENT_TYPE_TRIP,EVENT_TYPE_LEAVE)){
            result.add(String.format("%s函数的第三个参数只能输入外出、出差、请假其中一种",NAME));
        }
        if(!checkIn(unit,UNIT_HOUR,UNIT_MINUTE)){
            result.add(String.format("%s函数的第四个参数只能输入小时、分钟其中一种",NAME));
        }
        if(!checkIn(excludeRest,YES,NO)){
            result.add(String.format("%s函数的第五个参数只能输入是、否其中一种",NAME));
        }
        return result;
    }

    /**
     * 校验时间参数
     * @param param
     * @return
     */
    private boolean checkDate(FunctionParam param){
        if (param.getType() == FunctionParamType.CONSTANT){
            Object value = param.getValue();
            try {
                DateHelper.getDateTimeByStr(value.toString());
            }catch (Exception e){
                return false;
            }
        }
        return true;
    }

    /**
     * 校验值是否在指定范围内
     * @param param
     * @param allKeys
     * @return
     */
    private boolean checkIn(FunctionParam param,String... allKeys){
        if (param.getType() == FunctionParamType.CONSTANT){
            Object value = param.getValue();
            for(String key:allKeys){
                if(key.equals(value.toString())){
                    return true;
                }
            }
        }
        return false;
    }
}
```

其中**`calculate` 方法：**

- 实现了计算出勤时长的逻辑。接收指定的开始时间、结束时间、事件类型、时间单位和是否排除休息时间等参数。
- 从上下文中获取员工的出勤时间信息（`AttendanceTimePeriodInfo`）。
- 计算指定时间范围内的有效时段，考虑了事件类型和是否排除休息时间。
- 最终返回计算得到的出勤时长，单位可以是小时或分钟。











# 月报核算串讲





## 一、业务背景

员工一段时间内的行为（请假、加班、出差、外出、打卡、补卡等）集合，生成的报表数据用于展示、发薪、以及BI操作



## 二、关键词说明

串讲中或者系统中，出现频率比较高，且有一定业务含义或者承上启下作用的词语。这类词语往往因业务提炼度比较高，比较难从字面意思理解，需要做一些通俗的解释。最好配合示例说明。以考勤核算为例：

| 关键词       | 说明                                                         | 示例                                                         |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 月报配置     | 分为月报设置（包含封存状态，考勤确认区间等）、字段设置（包含预置字段、公式字段等） |                                                              |
| 竖表         | 月报中有一些租户纬度的"字段"，无法被直接定义成表的某个具体字段（因为每个租户都不一样），所以采取关联表的形式，关联表中的每一条数据，表示月报主表中的某一列。 | 如：hcm_abs_report_month_abnormal_status 表                  |
| 公式         | 与字段绑定、是一个自定义字段获得数据的逻辑（底层会依赖预置函数与业务函数，以及这些函数的上下文数据和所依赖的字段的数据） |                                                              |
| 月报账期     | 一个月报在一个月中 开始时间-结束时间 的区间（暂定，后续会有不定账期） | 月报配置账期为31，那么该月报1月份的账期为 1.1~1.31月报配置账期为26，那么该月报1月份的账期为12.25~1.26 |
| 月报         | 某个人在某个"月报账期"的"出勤记录"（最新的为日报数据）总览，里面涉及到很多数据(如请假、考勤异常、工作时长等)，并且都是运算得来的 |                                                              |
| 考勤确认通知 | 当月报配置开启了封存后，将会在账期结束后进行确认通知，员工可以点击确认，点击后月报的"考勤确认状态"会变为已确认 |                                                              |





## 三、服务架构图

![月报项目依赖图.drawio](https://cdn.jsdelivr.net/gh/amonstercat/PicGo/202312211717267.png)





## 四、核心业务逻辑



### 4.1.1 月报核算触发场景

 目前月报核算都是消息触发，每个场景是不同的消费者，并且只会在 `hcm-absence-statistics-cronjob` 进行核算

| 触发场景         | 调用接口                                                     |
| :--------------- | :----------------------------------------------------------- |
| 页面重新核算     | `com.moka.hcm.absence.kafka.listener.ReportMonthSingleCalculateListener#consumer` |
| 定时任务         | `com.moka.hcm.absence.kafka.listener.ReportMonthJobCalculateListener#listen` |
| 被动触发考勤核算 | `com.moka.hcm.absence.kafka.listener.ReportMonthCalculateListener#listen` |

月报核算流程图

| 接口名称    | 参数                                                         |
| ----------- | ------------------------------------------------------------ |
| `calculate` | `reportMonthConfigEntity(月报设置)、``needCalculateEmployeeIdList(需要核算员工id)、``accountPeriodDto(考勤账期)` |





![image-20231221172031424](https://cdn.jsdelivr.net/gh/amonstercat/PicGo/202312211720854.png)







### 4.1.2 月报核算



![月报核算逻辑.drawio](https://cdn.jsdelivr.net/gh/amonstercat/PicGo/202312211722992.png)





### 4.2.1 月报封存触发场景

月报封存的表除了和月报的表对应之外，还有基础数据封存表（比如 考勤记录封存表、排班封存表、请假、加班、出差、外出封存表等），目前页面使用的只是月报相关的封存表，基础数据封存表用于溯源。

月报封存相关的表：



| 表名                                        | 含义                                                         | 依赖数据接口 |
| ------------------------------------------- | ------------------------------------------------------------ | ------------ |
| 基础数据                                    |                                                              |              |
| hcm_abs_report_leave_data_freeze            | 请假数据封存表（拆分数据）                                   |              |
| hcm_abs_report_out_trip_data_freeze         | 外出数据封存表（拆分数据）                                   |              |
| hcm_abs_report_over_work_data_freeze        | 加班数据封存表（拆分数据）                                   |              |
| hcm_abs_report_business_trip_data_freeze    | 外出数据封存表（拆分数据）                                   |              |
| hcm_abs_patch_clock_freeze                  | 补卡封存表（拆分数据）                                       |              |
| hcm_abs_account_freeze                      | 假期账户封存表                                               |              |
| hcm_abs_attendance_record_freeze            | 考勤记录封存表                                               |              |
| hcm_abs_schedule_freeze                     | 排班的主表封存表                                             |              |
| hcm_abs_schedule_calendar_freeze            | 排班发布封存表                                               |              |
| hcm_abs_schedule_detail_freeze              | 排班人员封存表                                               |              |
|                                             |                                                              |              |
| 月报数据                                    |                                                              |              |
| hcm_abs_report_month_freeze                 | 月报封存主表→ 对应月报主表数据                               |              |
| hcm_abs_report_month_holiday_clear_freeze   | 月报离职清算封存表→对应月报离职清算数据                      |              |
| hcm_abs_report_month_leave_balance_freeze   | 月报自定义假期类型封存表→ 对应月报离职清算                   |              |
| hcm_abs_report_month_leave_freeze           | 出勤月报请假数据封存表→ 对应月报请假数据                     |              |
| hcm_abs_report_month_abnormal_status_freeze | 考勤异常状态月报封存表→ 考勤异常月报数据                     |              |
| hcm_abs_report_month_custom_field_freeze    | 月报结果扩展字段封存表-其它用户自定义字段→ 月报结果扩展字段表 |              |
| 月报封存状态                                |                                                              |              |
| hcm_abs_report_month_freeze_status          | 月报封存状态表                                               |              |
| hcm_abs_report_month_freeze_log             | 月报封存操作表                                               |              |
|                                             |                                                              |              |
|                                             |                                                              |              |



月报封存触发场景：不管是页面点击还是定时任务，最终都是调用 batchFreeze ，所以月报封存的收口只有一个！

| 触发场景                  | 说明                                                         | 触发事件                           | 调用接口                                                     |
| ------------------------- | ------------------------------------------------------------ | ---------------------------------- | ------------------------------------------------------------ |
| 页面点击全量封存/单人封存 |                                                              | 全量封存（单个也走全量，入参不同） | com.moka.hcm.absence.statistics.report.month.service.ReportMonthlyFreezeService#batchFreeze |
| 月报自动确认              | 考勤确认时间结束（封存时间到达）通过每晚01:00:00定时任务扫描 | 全量封存（单个也走全量，入参不同） | com.moka.hcm.absence.statistics.report.month.service.ReportMonthlyFreezeService#batchFreeze |
| 考勤确认通知              | 用户收到考勤确认通知，进入页面点击考勤确认，进行封存         | 全量封存（单个也走全量，入参不同） | com.moka.hcm.absence.statistics.report.month.service.ReportMonthlyFreezeService#batchFreeze |
| 页面点击解封              |                                                              | 全量解封                           | com.moka.hcm.absence.statistics.report.month.service.ReportMonthlyFreezeService#batchUnFreeze |







### 4.2.2 月报封存
